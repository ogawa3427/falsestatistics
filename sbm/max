#!/bin/sh

error() {
  echo "max: invalid input" >&2
  echo "Try 'max --help' for more information" >&2
  exit 1
}

maxpipe() {
#  echo "maxpipe" >&2

  num=0
  while IFS= read -r line; do
    if [ "$num" = 0 ]; then
      max="$line"
    fi
    if [ "$line" -gt "$max" ]; then
      max="$line"
    fi
    if [ "$num" -ge 1000 ] && [ $((num % 1000)) = 0 ]; then
      echo "line $num" >&2
    fi
    num=$((num + 1))
  done
  echo "$max"
  exit 0
}


minpipe() {
#  echo "minpipe" >&2

  num=0
  while IFS= read -r line; do
    if [ "$num" = 0 ]; then
      min="$line"
    fi
    if [ "$line" -lt "$min" ]; then
      min="$line"
    fi
    if [ "$num" -ge 1000 ] && [ $((num % 1000)) = 0 ]; then
      echo "line $num" >&2
    fi
    num=$((num + 1))
  done
  echo "$min"
  exit 0
}

maxfile() {
#  echo "maxfile" >&2

  num=0
  while IFS= read -r line; do
    if [ "$num" -eq 0 ]; then
      max="$line"
    fi
    if [ "$line" -gt "$max" ]; then
      max="$line"
    fi
    if [ $((num % 1000)) -eq 0 ]; then
      echo "line $num" >&2
    fi
    num=$((num + 1))
  done < "$1"
  echo "$max"
  exit 0
}

minfile() {
#  echo "minfile"

  num=0
  while IFS= read -r line; do
    if [ "$num" = 0 ]; then
      min="$line"
    fi
    if [ "$line" -lt "$min" ]; then
      min="$line"
    fi
    if [ "$num" -ge 1000 ] && [ $((num % 1000)) = 0 ]; then
      echo "line $num" >&2
    fi
    num=$((num + 1))
  done < "$1"
  echo "$min"
  exit 0
}

helping() {
  cat << EOF
NAME
  max - Calculates and outputs maximum value.
  max - 最大値を計算し、出力します。

SYNOPSIS
  max [OPTION] [FILE]

DESCRIPTION
  Using option "-i, --min", you can get minimum value.
  オプション "-iもしくは--min" で最小値を出力します。
  These commands provide you the maximum/minimum value using integer style value separated by changing line.
  このコマンドは改行で区切られた整数の値の列から最大/最小値を出力します。
  For persons who think "To be working, or not to be, that is the question." about this command, number of the line processed will be put into the default error output (2>)
  1000行ごとに処理した行の番号を標準エラー出力します、ちゃんと動いているか心配な方のために。
  You can use pipe, file input and redirection.
  パイプ、ファイル名指定、入力リダイレクトを使用できます。

OPTIONS
  -i/--min  - work as "min"(calculating minimum one)
              最小値を出力します。
  -h/--help - shows help page
              ヘルプページを表示します。
  (You can also use "--")
  (-- を使ってエスケープできます)

BUGS
  Strange action when give "-pi" as the option
  -piというオプションを入れるとおかしい

  It takes too long time to get output.
  出力までが遅すぎる。
  =>You might use Rust language, C language etc...
  =>最近話題のRustとかCでたぶん同じことができると思います。
  
  There are no advantage to write in Shell language.
  シェルで書く必要があると思えない
  =>If you realize so, should it be the time to learn how to use other tool such as Julia , MATLAB or sth like that? Please do not be so angry. I find Shell scripts as easily fixable, executable and remarkable tools.
  だったら別のなんか速い言語でやったら良いと思います
  そんなに興奮しないでください
  Unix系OSの環境で手軽に実行・改変できるようなソフトウェアを作る方法としてシェルスクリプトはとても価値があると思っています。
  手軽さのために犠牲にしているものがあるかもしれません。
  もしこのソフトウェアのパフォーマンスについて不満があるならば、それは重点を置く場所がわたしとあなたで異なっているということです。

AUTHOR
  Written by REN Shimizu
  Grammarly support by ChatGPT

REPORTING BUGS
  Stu-mail in KU or twitter @stspecedjpstuku

COPYRIGHT
  You can change and use this script for any ways.
  There is no warranty, extent limitation by the law.
  このスクリプトはあなたが任意の方法で変更し使用することができます。
  保証はありません、法律による制約範囲内で。

SEE ALSO
  https://jp.mathworks.com/products/matlab.html
  https://julialang.org/
EOF
  exit 0
}


#不正な引数が入力されたら弾く
#香川式
filnum=0
optnum=0
dasnum=0

if [ -n "$1" ] && [ "$(echo "$1" | cut -c1)" != "-" ]; then
  filnum=$(expr $filnum + 1)
fi
if [ -n "$2" ] && [ "$(echo "$2" | cut -c1)" != "-" ]; then
  filnum=$(expr $filnum + 1)
fi
if [ -n "$3" ] && [ "$(echo "$3" | cut -c1)" != "-" ]; then
  filnum=$(expr $filnum + 1)
fi

case "$1" in
  -[a-z]*)
    optnum=$(expr $optnum + 1)
    ;;
  *)
    :
    ;;
esac
case "$2" in
  -[a-z]*)
    optnum=$(expr $optnum + 1)
    ;;
  *)
    :
    ;;
esac
case "$3" in
  -[a-z]*)
    optnum=$(expr $optnum + 1)
    ;;
  *)
    :
    ;;
esac

if [ "$(echo "$1" | grep -- "-[a-z]" | wc -l )" = "1" ]; then
  dasnum=$(expr $dasnum + 1)
fi
if [ "$(echo "$2" | grep -- "--" | wc -l )" = "1" ]; then
  dasnum=$(expr $dasnum + 1)
fi
if [ "$(echo "$3" | grep -- "--" | wc -l )" = "1" ]; then
  dasnum=$(expr $dasnum + 1)
fi
echo start
echo $optnum
echo $filnum
echo $dasnum
echo fin

# はじき
if [ $optnum -gt 1 ];then
  error
fi
if [ $filnum -gt 1 ];then
  error
fi
if [ $dasnum -gt 1 ];then
  error
fi



#オプション
che="$1$2$3"
ched="$(echo "$che" | sed 's/--min//g' | sed 's/-i//g' | sed 's/--help//g' | sed 's/-h//g' | sed 's/--//g' )"
if [ -n "$ched" ]; then
  error
fi

#--
echo "1"

# ヘルプ関係＆不正なヘルプ呼出を切る
case "$1" in
  -h|--help)
    if [ -n "$2" ] || [ -n "$3" ] || [ -n "$4" ] || [ -n "$5" ] || [ -n "$6" ] || [ -n "$7" ] || [ -n "$8" ]; then
      error
    else
      helping
    fi
    ;;
esac

# -- を読み取り＆不正なものを切る
if [ "$1" = "--" ]; then
  if [ -n "$3$4$5$6$7$8" ]; then
    error
  else
    maxfile "$2"
  fi
fi

if [ "$2" = "--" ]; then
  file="$3"
  if [ -n "$4$5$6$7$8" ]; then
    error
  else
    case "$1" in
      -i|--min)
        minfile "$3"
        ;;
    esac
    error
  fi
fi

# ３引数以上なら切る
if [ -n "$3$4$5$6$7$8" ]; then
  error
fi

optnum=0
filnum=0

#if第n引数が-から始まる引数を数える
if [ "$(echo "$1" | grep '-m|--min' | wc -l )" = "1" ]; then
  optnum=$(expr $optnum + 1)
  filename="$2"
fi
if [ $(echo "$2" | grep '-m|--min' | wc -l ) = 1 ]; then
  optnum=$(expr $optnum + 1)
  filename="$1"
fi

#if空でない引数を数える
if [ -n "$1" ] && [ "$(echo "$1" | cut -c1)" != "-" ]; then
  filnum=$(expr $filnum + 1)
fi

if [ -n "$2" ] && [ "$(echo "$2" | cut -c1)" != "-" ]; then
  filnum=$(expr $filnum + 1)
fi

# 不正な２引数を切る
if [ $optnum = 2 ]; then
  error
fi

if [ $filnum = 2 ]; then
  error
fi

# ２引数で動くものを処理
if [ $optnum = 1 ] && [ $filnum = 1 ]; then
  minfile "$filename"
fi

#１or０引数で動くものを処理
if [ $filnum = 1 ]; then
  maxfile "$1"
elif [ $optnum = 1 ]; then
  minpipe
else
  maxpipe
fi

# 最終手段
error