#!/bin/sh
###関数定義で可読性向上&ファイルサイズ削減セクション
##組み込まれエリア
oscreen() {
  case "$1" in
    -i|--min)
      :
      ;;
    *)
      echo "Undifined option"
      error
      ;;
  esac
}

fscreen() {
  if [ ! -f "$1" ]; then
    echo "Error:max: not a file."
    error
  else
    :
  fi
}

error() {
  echo "max: invalid input" >&2
  echo "Try 'max --help' for more information" >&2
  exit 1
}

##分岐後処理エリア
maxpipe() {
#  echo "maxpipe" >&2

  num=0
  while IFS= read -r line; do
    if [ "$num" = 0 ]; then
      max="$line"
    fi
    if [ "$line" -gt "$max" ]; then
      max="$line"
    fi
    if [ "$num" -ge 1000 ] && [ $((num % 1000)) = 0 ]; then
      echo "line $num" >&2
    fi
    num=$((num + 1))
  done
  echo "$max"
  exit 0
}


minpipe() {
#  echo "minpipe" >&2

  num=0
  while IFS= read -r line; do
    if [ "$num" = 0 ]; then
      min="$line"
    fi
    if [ "$line" -lt "$min" ]; then
      min="$line"
    fi
    if [ "$num" -ge 1000 ] && [ $((num % 1000)) = 0 ]; then
      echo "line $num" >&2
    fi
    num=$((num + 1))
  done
  echo "$min"
  exit 0
}

maxfile() {
#  echo "maxfile" >&2
  fscreen "$1"
  num=0
  while IFS= read -r line; do
    if [ "$num" -eq 0 ]; then
      max="$line"
    fi
    if [ "$line" -gt "$max" ]; then
      max="$line"
    fi
    if [ $((num % 1000)) -eq 0 ]; then
      echo "line $num" >&2
    fi
    num=$((num + 1))
  done < "$1"
  echo "$max"
  exit 0
}

minfile() {
#  echo "minfile"
  fscreen "$1"
  num=0
  while IFS= read -r line; do
    if [ "$num" = 0 ]; then
      min="$line"
    fi
    if [ "$line" -lt "$min" ]; then
      min="$line"
    fi
    if [ "$num" -ge 1000 ] && [ $((num % 1000)) = 0 ]; then
      echo "line $num" >&2
    fi
    num=$((num + 1))
  done < "$1"
  echo "$min"
  exit 0
}

helping() {
  cat << EOF
NAME
  max - Calculates and outputs maximum value.
  max - 最大値を計算し、出力します。

SYNOPSIS
  max [OPTION] [FILE]

DESCRIPTION
  Using option "-i, --min", you can get minimum value.
  オプション "-iもしくは--min" で最小値を出力します。
  These commands provide you the maximum/minimum value using integer style value separated by changing line.
  このコマンドは改行で区切られた整数の値の列から最大/最小値を出力します。
  For persons who think "To be working, or not to be, that is the question." about this command, number of the line processed will be put into the default error output (2>)
  1000行ごとに処理した行の番号を標準エラー出力します、ちゃんと動いているか心配な方のために。
  You can use pipe, file input and redirection.
  パイプ、ファイル名指定、入力リダイレクトを使用できます。

OPTIONS
  -i/--min  - work as "min"(calculating minimum one)
              最小値を出力します。
  -h/--help - shows help page
              ヘルプページを表示します。
  (You can also use "--")
  (-- を使ってエスケープできます)

BUGS
  Strange action when give "-pi" as the option
  -piというオプションを入れるとおかしい

  It takes too long time to get output.
  出力までが遅すぎる。
  =>You might use Rust language, C language etc...
  =>最近話題のRustとかCでたぶん同じことができると思います。
  
  There are no advantage to write in Shell language.
  シェルで書く必要があると思えない
  =>If you realize so, should it be the time to learn how to use other tool such as Julia , MATLAB or sth like that? Please do not be so angry. I find Shell scripts as easily fixable, executable and remarkable tools.
  だったら別のなんか速い言語でやったら良いと思います
  そんなに興奮しないでください
  Unix系OSの環境で手軽に実行・改変できるようなソフトウェアを作る方法としてシェルスクリプトはとても価値があると思っています。
  手軽さのために犠牲にしているものがあるかもしれません。
  もしこのソフトウェアのパフォーマンスについて不満があるならば、それは重点を置く場所がわたしとあなたで異なっているということです。

AUTHOR
  Written by REN Shimizu
  Grammarly support by ChatGPT

REPORTING BUGS
  Stu-mail in KU or twitter @stspecedjpstuku

COPYRIGHT
  You can change and use this script for any ways.
  There is no warranty, extent limitation by the law.
  このスクリプトはあなたが任意の方法で変更し使用することができます。
  保証はありません、法律による制約範囲内で。

SEE ALSO
  https://jp.mathworks.com/products/matlab.html
  https://julialang.org/
EOF
  exit 0
}

###正しいフォームでコマンドが実行されているか＆引数が有効か？
#countif=3
if [ $# -ge 4 ]; then
  echo "Too many arguments."
  error
fi
if [ $# -eq 3 ]; then
  if [ "$2" = "--" ]; then
    oscreen "$1"
    minfile "$3" #111
  else
    error
  fi
fi

#countif=2
if [ $# -eq 2 ]; then
  if [ "$2" = "--" ];then
    error #110
  elif [ "$1" = "--" ]; then
    maxfile "$2" #011
  else
    oscreen "$1"
    minfile "$2" #101
  fi
fi

#countif=1
if [ $# -eq 1 ]; then
  if [ "$1" = "--" ]; then
    error #010
  else
    if [ "$(echo "$1" | cut -c1)" = "-" ]; then
      oscreen "$1"
      maxpipe #100
    else
      maxfile "$1" #001
    fi
  fi
fi

#countif=0
maxpipe

#最終手段
error